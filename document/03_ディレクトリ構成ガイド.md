# ディレクトリ構成ガイド

このドキュメントでは、Vue3 プロジェクトのディレクトリ構成と、「どこに何を置くか」のルールを説明します。

---

## プロジェクト全体構成

このプロジェクトでは、Vue2 / Vue3 で共通利用するコードを `fe-libs/` に配置し、アプリ固有のコードを `src/` に配置します。

```
repo-root/
├── fe-libs/                           # Vue2 / Vue3 共通ライブラリ
│   ├── mocks/                         # MSW モック定義（共通化）
│   │   ├── scenarioManager.ts         # シナリオ管理
│   │   ├── handlers/                  # API ごとの handler
│   │   │   ├── index.ts
│   │   │   ├── {機能名}.handlers.ts
│   │   │   └── {機能名}.error.handlers.ts
│   │   ├── fixtures/                  # レスポンス用データ（機能別）
│   │   │   └── {機能名}/
│   │   │       ├── index.ts
│   │   │       ├── {機能名}.normal.ts
│   │   │       └── {機能名}.large.ts
│   │   └── scenarios/                 # handler セット（切り替え用）
│   │       └── {機能名}.scenarios.ts
│   │
│   └── types/                         # API DTO 型定義
│       ├── generated/                 # OpenAPI から自動生成（編集禁止）
│       │   └── openapi.d.ts
│       └── index.ts
│
└── src/
    ├── app/                           # アプリ初期化（1箇所）
    │   ├── App.vue
    │   ├── main.ts
    │   ├── router/
    │   └── plugins/
    │
    ├── pages/                         # 画面（ルーティング入口のみ）
    │   └── {機能名}/
    │       ├── XxxListPage.vue
    │       ├── XxxCreatePage.vue
    │       └── XxxEditPage.vue
    │
    ├── widgets/                       # 画面の骨組み（状態とsectionsを結合）
    │   └── {機能名}/
    │       ├── XxxListWidget/
    │       │   ├── XxxListWidget.vue
    │       │   └── index.ts
    │       └── XxxFormWidget/
    │
    ├── sections/                      # 表示・入力の塊（props/emit完結）
    │   └── {機能名}/
    │       ├── XxxTableSection/
    │       │   ├── XxxTableSection.vue
    │       │   ├── XxxTableSection.stories.ts  # Storybook
    │       │   └── index.ts
    │       └── XxxFormSection/
    │
    ├── shared/                        # アプリ全体で共有
    │   └── ui/                        # 共通UIコンポーネント
    │       ├── AppHeader/
    │       │   ├── AppHeader.vue
    │       │   ├── AppHeader.stories.ts
    │       │   └── index.ts
    │       └── ConfirmDialog/
    │
    ├── features/                      # 機能別のロジック層
    │   └── {機能名}/
    │       ├── model/                 # Composable（状態・API呼び出し）
    │       │   ├── useXxxList.ts
    │       │   ├── useXxxForm.ts
    │       │   └── index.ts
    │       └── types/                 # 機能固有の型定義
    │           └── index.ts
    │
    ├── entities/                      # ドメインロジック（純関数）
    │   └── {ドメイン名}/
    │       ├── validate.ts
    │       └── transform.ts
    │
    ├── services/                      # 共通APIサービス（複数機能で使う場合のみ）
    │   └── authService.ts
    │
    ├── stores/                        # Pinia ストア（アプリ全体で共有）
    │   └── masterStore.ts
    │
    ├── mocks/                         # MSW初期化（アプリ固有）
    │   └── browser.ts
    │
    └── devtools/                      # 開発用ツール
        └── MswScenarioSwitcher.vue
```

---

## CDD 設計との対応

| CDD の概念 | ディレクトリ | 説明 |
|------------|--------------|------|
| pages | `src/pages/{機能名}/` | ルーティング入口 |
| widgets | `src/widgets/{機能名}/` | 画面の骨組み |
| sections | `src/sections/{機能名}/` | 表示・入力の塊 |
| features/model | `src/features/{機能名}/model/` | 状態・API呼び出し |
| features/types | `src/features/{機能名}/types/` | 機能固有の型（再エクスポート） |
| entities | `src/entities/` | ドメインロジック |
| shared/ui | `src/shared/ui/` | 共通 UI 部品 |
| stores | `src/stores/` | アプリ全体で共有する状態 |
| services | `src/services/` | 複数機能で共通利用するAPI |
| DTO型定義 | `fe-libs/types/` | API型定義（一元管理） |
| MSW モック | `fe-libs/mocks/` | Vue2/Vue3 共通 |
| MSW モック | `fe-libs/mocks/` | Vue2/Vue3 共通 |

---

## 各ディレクトリの詳細

### src/pages/

画面ごとにフォルダを作成します。**ルーティング入口のみ**を担当します。

```
src/pages/
├── tasks/
│   ├── TaskListPage.vue       # 一覧画面
│   ├── TaskCreatePage.vue     # 登録画面
│   └── TaskEditPage.vue       # 編集画面
└── orders/
    ├── OrderListPage.vue
    └── OrderDetailPage.vue
```

**例：**

```vue
<!-- pages/tasks/TaskListPage.vue -->
<template>
  <TaskListWidget />
</template>

<script setup lang="ts">
import { TaskListWidget } from '@/widgets/tasks'
</script>
```

**ルール：**
- 機能名のフォルダを作る（`tasks/`, `orders/` など）
- ファイル名は `Xxx{機能}Page.vue`
- **ロジックは書かない**（Widget に委譲）

---

### src/widgets/

画面の骨組みを担当します。**model から状態を取得し、sections に配布**します。

```
src/widgets/
└── tasks/
    ├── TaskListWidget/
    │   ├── TaskListWidget.vue
    │   └── index.ts
    ├── TaskFormWidget/
    │   ├── TaskFormWidget.vue
    │   └── index.ts
    └── TaskDetailSidebar/
        ├── TaskDetailSidebar.vue
        └── index.ts
```

**例：**

```vue
<!-- widgets/tasks/TaskListWidget/TaskListWidget.vue -->
<template>
  <TaskTableSection
    :tasks="tasks"
    :is-loading="isLoading"
    @select="handleSelect"
  />
</template>

<script setup lang="ts">
import { onMounted } from 'vue'
import { TaskTableSection } from '@/sections/tasks'
import { useTaskList } from '@/features/tasks/model'

const { tasks, isLoading, fetchTasks, selectTask } = useTaskList()

onMounted(() => fetchTasks())

function handleSelect(taskId: string) {
  selectTask(taskId)
}
</script>
```

**ルール：**
- model（Composable）から状態を取得
- sections に props で渡す
- emit を受けて actions を呼ぶ
- **直接 API を呼ばない**（model に委譲）

---

### src/sections/

**表示・入力の塊**を担当します。props と emit だけで完結します。

```
src/sections/
└── tasks/
    ├── TaskTableSection/
    │   ├── TaskTableSection.vue
    │   ├── TaskTableSection.stories.ts  # Storybook
    │   └── index.ts
    ├── TaskFormSection/
    │   ├── TaskFormSection.vue
    │   ├── TaskFormSection.stories.ts
    │   └── index.ts
    └── index.ts                          # 集約 export
```

**例：**

```vue
<!-- sections/tasks/TaskTableSection/TaskTableSection.vue -->
<template>
  <v-data-table
    :headers="headers"
    :items="tasks"
    :loading="isLoading"
    @click:row="(_, { item }) => emit('select', item.id)"
  />
</template>

<script setup lang="ts">
import type { Task } from '@/features/tasks/types'

interface Props {
  tasks: Task[]
  isLoading?: boolean
}

defineProps<Props>()

const emit = defineEmits<{
  select: [taskId: string]
}>()

const headers = [
  { title: '作業日', key: 'workDate' },
  { title: '作業者', key: 'workers' },
]
</script>
```

**ルール：**
- **props で値を受け取る**
- **emit でイベントを返す**
- API を呼ばない、Store を参照しない
- Storybook の Story を作成する

---

### src/shared/ui/

アプリ全体で再利用する**共通 UI 部品**を配置します。

```
src/shared/ui/
├── AppHeader/
│   ├── AppHeader.vue
│   ├── AppHeader.stories.ts
│   └── index.ts
├── ConfirmDialog/
│   ├── ConfirmDialog.vue
│   ├── ConfirmDialog.stories.ts
│   └── index.ts
├── AppToast/
│   └── ...
└── index.ts                    # 集約 export
```

**ルール：**
- 業務ロジックを持たない
- どの画面でも同じ見た目・動作
- Storybook の Story を作成する

---

### src/features/{機能名}/model/

**状態管理と API 呼び出し**を担当する Composable を配置します。

```
src/features/
└── tasks/
    ├── model/
    │   ├── useTaskList.ts      # 一覧の状態・操作
    │   ├── useTaskForm.ts      # フォームの状態・操作
    │   └── index.ts
    └── types/
        └── index.ts            # 機能固有の型
```

**例：**

```typescript
// features/tasks/model/useTaskList.ts
import { ref, computed } from 'vue'
import type { Task } from '../types'

export function useTaskList() {
  // ===== State =====
  const tasks = ref<Task[]>([])
  const isLoading = ref(false)
  const error = ref<Error | null>(null)

  // ===== Computed =====
  const isEmpty = computed(() => tasks.value.length === 0)

  // ===== Actions =====
  async function fetchTasks() {
    isLoading.value = true
    try {
      const res = await fetch('/api/tasks')
      tasks.value = await res.json()
    } catch (e) {
      error.value = e instanceof Error ? e : new Error(String(e))
    } finally {
      isLoading.value = false
    }
  }

  return { tasks, isLoading, error, isEmpty, fetchTasks }
}
```

**ルール：**
- State / Computed / Actions / Watchers の4セクション構成
- API 呼び出しは Actions 内で行う
- エラーハンドリングを含める

---

### src/entities/

**ドメインロジック**（純関数）を配置します。

```
src/entities/
└── task/
    ├── validate.ts
    └── transform.ts
```

**例：**

```typescript
// entities/task/validate.ts
export interface TaskValidationResult {
  valid: boolean
  errors: Record<string, string>
}

export function validateTask(task: { workDate: string; workerIds: string[] }): TaskValidationResult {
  const errors: Record<string, string> = {}

  if (!task.workDate) {
    errors.workDate = '作業日は必須です'
  }

  if (task.workerIds.length === 0) {
    errors.workerIds = '作業者を1名以上選択してください'
  }

  return {
    valid: Object.keys(errors).length === 0,
    errors
  }
}
```

**ルール：**
- UI に依存しない
- API に依存しない
- 副作用を持たない純関数

---

### src/services/

**複数機能で共通利用する API 呼び出し**のみ配置します。

```
src/services/
└── authService.ts
```

**例：**

```typescript
// services/authService.ts
export async function getCurrentUser(): Promise<User> {
  const res = await fetch('/api/auth/me')
  return res.json()
}

export async function logout(): Promise<void> {
  await fetch('/api/auth/logout', { method: 'POST' })
}
```

**判断基準：**
- 1つの Composable からしか使わない → **model 内に書く**
- 複数の Composable や機能で使う → **services に切り出す**

---

### src/stores/

**アプリ全体で共有する状態**を Pinia ストアとして配置します。

```
src/stores/
├── masterStore.ts     # マスタデータ（全画面で参照）
└── authStore.ts       # 認証情報
```

**例：**

```typescript
// stores/masterStore.ts
import { defineStore } from 'pinia'
import { ref } from 'vue'
import type { Worker, Machine, Material, Unit } from '@/features/master/types'

export const useMasterStore = defineStore('master', () => {
  const workers = ref<Worker[]>([])
  const machines = ref<Machine[]>([])
  const materials = ref<Material[]>([])
  const units = ref<Unit[]>([])
  const initialized = ref(false)

  async function fetchMasters() {
    const res = await fetch('/api/masters')
    const data = await res.json()
    workers.value = data.workers
    machines.value = data.machines
    materials.value = data.materials
    units.value = data.units
    initialized.value = true
  }

  return { workers, machines, materials, units, initialized, fetchMasters }
})
```

**ルール：**
- **アプリ全体で共有するデータ**のみ Store に置く
- 画面固有の状態は `features/{機能名}/model/useXxx.ts` に置く

---

### src/features/{機能名}/types/

**API 型定義（DTO）を各機能でローカルに再エクスポート**します。

```
src/features/
├── tasks/
│   ├── types/
│   │   └── index.ts             # @fe-libs/types を再エクスポート
│   └── model/
│       └── useTaskList.ts        # @/features/tasks/types からインポート
└── master/
    ├── types/
    │   └── index.ts             # @fe-libs/types を再エクスポート
    └── model/
        └── masterStore.ts        # @/features/master/types からインポート
```

**例：**

```typescript
// src/features/tasks/types/index.ts
export * from '@fe-libs/types'
```

**メリット：**
- 見通しの良さ：型定義と実装が物理的に近い
- 一元管理：実装は `fe-libs/types/` で統一
- Vue2/Vue3共有：`@fe-libs/types` から両方がインポート可能
- 開発体験：新規機能追加時に型と実装を一緒に確認できる

---

### fe-libs/types/（API 型定義）

**OpenAPI から自動生成される、または手動で一元管理される API の DTO 型定義**を配置します。

```
fe-libs/types/
├── index.ts              # 集約エクスポート
├── tasks.ts              # タスク関連の型
└── masters.ts            # マスタ関連の型
```

**例：**

```typescript
// fe-libs/types/tasks.ts
export interface Task {
  id: string
  workDate: string
  workers: TaskWorker[]
  machine: TaskMachine
  materials: TaskMaterial[]
  createdAt: string
  updatedAt: string
}

export interface CreateTaskRequest {
  workDate: string
  workerIds: string[]
  machineId: string
  materials: CreateTaskMaterial[]
}

export interface TaskListResponse {
  items: Task[]
  total: number
  page: number
  limit: number
  totalPages: number
}
```

**ルール：**
- 実装は `fe-libs/types/` に一元管理
- 各機能の `types/index.ts` から再エクスポート
- OpenAPI 自動生成ツールのターゲット
- Vue2 / Vue3 両方から `@fe-libs/types` でインポート

---

### fe-libs/mocks/（MSW モック定義）

MSW の handler / fixture / scenario は Vue2 / Vue3 で共通利用するため、`fe-libs/mocks/` に配置します。

```
fe-libs/mocks/
├── scenarioManager.ts           # シナリオ管理
├── handlers/                    # API ごとの handler
│   ├── index.ts                 # handler の集約
│   ├── tasks.handlers.ts        # タスク API（正常系）
│   ├── tasks.error.handlers.ts  # タスク API（エラー系）
│   └── masters.handlers.ts      # マスター API
├── fixtures/                    # レスポンス用データ（機能別）
│   ├── tasks/
│   │   ├── index.ts
│   │   ├── tasks.normal.ts      # 通常データ（5〜15件）
│   │   └── tasks.large.ts       # 大量データ（50〜100件）
│   └── masters/
│       ├── workers.ts
│       ├── machines.ts
│       ├── materials.ts
│       └── units.ts
├── scenarios/                   # handler セット
│   ├── index.ts
│   └── tasks.scenarios.ts
└── index.ts
```

**ルール：**
- handler / fixture / scenario の **定義** は `fe-libs/mocks/` に置く
- MSW の **初期化**（`setupWorker`）は各アプリ（`src/mocks/`）に置く
- fixture は API レスポンスと完全一致させる
- 機能が増えるごとに `fixtures/{機能名}/` フォルダを追加

---

## ファイル命名規則

| 種類 | 命名規則 | 例 |
|------|----------|-----|
| Page | `Xxx{機能}Page.vue` | `TaskListPage.vue` |
| Widget | `Xxx{機能}Widget.vue` | `TaskListWidget.vue` |
| Section | `Xxx{機能}Section.vue` | `TaskTableSection.vue` |
| 共通UI | `XxxComponent.vue` | `AppHeader.vue` |
| Composable | `useXxx.ts` | `useTaskList.ts` |
| ストア | `xxxStore.ts` | `masterStore.ts` |
| サービス | `xxxService.ts` | `authService.ts` |
| ハンドラー | `xxx.handlers.ts` | `tasks.handlers.ts` |
| フィクスチャ | `xxx.{パターン}.ts` | `tasks.normal.ts` |
| 型定義 | PascalCase | `Task`, `CreateTaskRequest` |

---

## 新しいファイルを作るときの判断フロー

```
何を作りたい？
    │
    ├─ 画面の入口 → src/pages/{機能名}/XxxPage.vue
    │
    ├─ 画面の骨組み → src/widgets/{機能名}/XxxWidget/
    │
    ├─ 表示・入力の塊 → src/sections/{機能名}/XxxSection/
    │
    ├─ 複数画面で使う UI 部品 → src/shared/ui/Xxx/
    │
    ├─ 状態・API呼び出し → src/features/{機能名}/model/useXxx.ts
    │
    ├─ 複数機能で使うAPI → src/services/xxxService.ts
    │
    ├─ ドメインロジック → src/entities/{ドメイン}/xxx.ts
    │
    ├─ 全画面で共有する状態 → src/stores/xxxStore.ts
    │
    ├─ API モック（handler/fixture） → fe-libs/mocks/handlers/xxx.handlers.ts
    │
    └─ API 型定義（DTO） → fe-libs/types/（自動生成）
```

---

## よくある質問

### Q: widgets と sections の違いは？

| | widgets | sections |
|---|---------|----------|
| **役割** | 状態と UI の結合 | 表示・入力の塊 |
| **状態を持つ** | ❌（model に委譲） | UI状態のみ |
| **API を呼ぶ** | ❌（model に委譲） | ❌ |
| **Storybook** | ❌ 対象外 | ✅ 対象 |
| **props/emit** | sections と接続 | 完全に props/emit 完結 |

### Q: Store と useXxx.ts（model）の違いは？

| | Store | useXxx.ts（model） |
|---|-------|-------------------|
| **スコープ** | アプリ全体 | 画面・機能固有 |
| **寿命** | アプリ終了まで | 画面離脱で破棄 |
| **用途** | マスタデータ、認証情報 | フォーム入力、一覧状態 |
| **配置** | `src/stores/` | `src/features/{機能}/model/` |

### Q: services に書くべきか model に書くべきか？

| 状況 | 配置先 |
|------|--------|
| 1つの Composable からしか呼ばない | model 内に書く |
| 複数の Composable や機能で使う | services に切り出す |
| 認証・ログアウトなど共通処理 | services に書く |

---

## コンポーネント間のデータフロー

```
[Page]
   │
   └─ [Widget]
         │
         ├─ useXxx() から状態を取得
         │
         ├─ [Section A] ← props で配布
         │      └─ emit → actions.xxx()
         │
         └─ [Section B] ← props で配布
                └─ emit → actions.xxx()

状態が更新 → 再描画
```

---

## 次のステップ

ディレクトリ構成を理解したら、[04_実装パターン集](./04_実装パターン集.md) で具体的なコードパターンを確認しましょう。
