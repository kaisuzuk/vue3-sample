# 実装パターン集

このドキュメントでは、Vue3 + CDD で頻出する実装パターンをコード例付きで紹介します。
「どう書けばいいかわからない」ときに参照してください。

---

## 1. Page → Widget → Section の基本パターン

### Page（ルーティング入口）

```vue
<!-- pages/items/ItemsListPage.vue -->
<template>
  <div class="items-page">
    <h1>商品一覧</h1>
    <ItemsListWidget />
  </div>
</template>

<script setup lang="ts">
import ItemsListWidget from './ItemsListWidget.vue'
</script>
```

### Widget（状態とUIの接続）

```vue
<!-- pages/items/ItemsListWidget.vue -->
<template>
  <div class="items-widget">
    <!-- ローディング表示 -->
    <div v-if="ui.loading" class="loading">読み込み中...</div>
    
    <!-- エラー表示 -->
    <div v-else-if="ui.hasError" class="error">
      {{ errors.message }}
      <button @click="actions.load">再試行</button>
    </div>
    
    <!-- 正常表示 -->
    <template v-else>
      <ItemsSearchSection
        :keyword="view.keyword"
        @update:keyword="actions.updateKeyword"
        @search="actions.search"
      />
      
      <ItemsTableSection
        :items="view.items"
        @select="actions.selectItem"
        @delete="actions.deleteItem"
      />
      
      <ItemsPaginationSection
        :page="view.page"
        :totalPages="view.totalPages"
        @change="actions.changePage"
      />
    </template>
  </div>
</template>

<script setup lang="ts">
import { onMounted } from 'vue'
import { useItemsList } from './useItemsList'
import ItemsSearchSection from './sections/ItemsSearchSection.vue'
import ItemsTableSection from './sections/ItemsTableSection.vue'
import ItemsPaginationSection from './sections/ItemsPaginationSection.vue'

const { view, ui, errors, actions } = useItemsList()

onMounted(() => {
  actions.load()
})
</script>
```

### Section（表示・入力に専念）

```vue
<!-- pages/items/sections/ItemsTableSection.vue -->
<template>
  <table class="items-table">
    <thead>
      <tr>
        <th>商品名</th>
        <th>価格</th>
        <th>操作</th>
      </tr>
    </thead>
    <tbody>
      <tr v-for="item in items" :key="item.id">
        <td>{{ item.name }}</td>
        <td>{{ item.price.toLocaleString() }}円</td>
        <td>
          <button @click="$emit('select', item.id)">詳細</button>
          <button @click="$emit('delete', item.id)">削除</button>
        </td>
      </tr>
    </tbody>
  </table>
  
  <p v-if="items.length === 0" class="empty-message">
    商品がありません
  </p>
</template>

<script setup lang="ts">
interface Item {
  id: string
  name: string
  price: number
}

defineProps<{
  items: Item[]
}>()

defineEmits<{
  select: [id: string]
  delete: [id: string]
}>()
</script>
```

---

## 2. useXxx（model）の基本パターン

```typescript
// pages/items/useItemsList.ts
import { ref, computed } from 'vue'
import { fetchItems, deleteItem } from '@/services/itemsService'
import type { Item } from '@/contracts/items'

export const useItemsList = () => {
  // ========================================
  // 1. 状態（state）
  // ========================================
  const items = ref<Item[]>([])
  const keyword = ref('')
  const page = ref(1)
  const loading = ref(false)
  const error = ref<string | null>(null)

  // ========================================
  // 2. 表示用の導出値（view）
  // ========================================
  const view = computed(() => {
    // キーワードでフィルタ
    const filtered = items.value.filter(item =>
      item.name.includes(keyword.value)
    )
    
    // ページング
    const perPage = 10
    const start = (page.value - 1) * perPage
    const paginated = filtered.slice(start, start + perPage)

    return {
      items: paginated,
      keyword: keyword.value,
      page: page.value,
      totalPages: Math.ceil(filtered.length / perPage),
      totalCount: filtered.length
    }
  })

  // ========================================
  // 3. UI 状態
  // ========================================
  const ui = computed(() => ({
    loading: loading.value,
    hasError: error.value !== null,
    isEmpty: items.value.length === 0 && !loading.value
  }))

  // ========================================
  // 4. エラー
  // ========================================
  const errors = computed(() => ({
    message: error.value
  }))

  // ========================================
  // 5. 操作（actions）
  // ========================================
  const actions = {
    async load() {
      loading.value = true
      error.value = null
      try {
        items.value = await fetchItems()
      } catch (e) {
        error.value = 'データの取得に失敗しました'
      } finally {
        loading.value = false
      }
    },

    updateKeyword(newKeyword: string) {
      keyword.value = newKeyword
      page.value = 1 // キーワード変更時は1ページ目に戻る
    },

    search() {
      page.value = 1
      // 必要なら再取得
    },

    changePage(newPage: number) {
      page.value = newPage
    },

    selectItem(id: string) {
      // 詳細画面への遷移など
      console.log('Selected:', id)
    },

    async deleteItem(id: string) {
      if (!confirm('削除しますか？')) return
      
      try {
        await deleteItem(id)
        items.value = items.value.filter(item => item.id !== id)
      } catch (e) {
        error.value = '削除に失敗しました'
      }
    }
  }

  return { view, ui, errors, actions }
}
```

---

## 3. フォーム入力のパターン

### 入力フォームの model

```typescript
// pages/items/useItemForm.ts
import { ref, computed } from 'vue'
import { createItem } from '@/services/itemsService'
import { validateItem } from '@/domain/item'
import type { CreateItemRequest } from '@/contracts/items'

export const useItemForm = () => {
  // ========================================
  // フォーム値（form）
  // ========================================
  const form = ref<CreateItemRequest>({
    name: '',
    price: 0
  })

  // ========================================
  // UI 状態
  // ========================================
  const touched = ref({
    name: false,
    price: false
  })
  const submitting = ref(false)
  const submitError = ref<string | null>(null)

  // ========================================
  // バリデーション
  // ========================================
  const validation = computed(() => validateItem(form.value))

  const errors = computed(() => ({
    name: touched.value.name ? validation.value.errors.name : undefined,
    price: touched.value.price ? validation.value.errors.price : undefined
  }))

  // ========================================
  // 導出値
  // ========================================
  const canSubmit = computed(() =>
    validation.value.valid && !submitting.value
  )

  // ========================================
  // 操作
  // ========================================
  const actions = {
    updateField<K extends keyof CreateItemRequest>(
      field: K,
      value: CreateItemRequest[K]
    ) {
      form.value[field] = value
      touched.value[field] = true
    },

    async submit() {
      // 全フィールドを touched にする
      touched.value = { name: true, price: true }

      if (!validation.value.valid) {
        return { success: false }
      }

      submitting.value = true
      submitError.value = null

      try {
        const created = await createItem(form.value)
        return { success: true, data: created }
      } catch (e) {
        submitError.value = '保存に失敗しました'
        return { success: false }
      } finally {
        submitting.value = false
      }
    },

    reset() {
      form.value = { name: '', price: 0 }
      touched.value = { name: false, price: false }
      submitError.value = null
    }
  }

  return {
    form,
    errors,
    ui: computed(() => ({
      submitting: submitting.value,
      canSubmit: canSubmit.value,
      submitError: submitError.value
    })),
    actions
  }
}
```

### フォーム Section

```vue
<!-- pages/items/sections/ItemFormSection.vue -->
<template>
  <form @submit.prevent="$emit('submit')">
    <div class="form-group">
      <label for="name">商品名</label>
      <input
        id="name"
        type="text"
        :value="form.name"
        @input="$emit('update:name', ($event.target as HTMLInputElement).value)"
        :disabled="disabled"
      />
      <span v-if="errors.name" class="error">{{ errors.name }}</span>
    </div>

    <div class="form-group">
      <label for="price">価格</label>
      <input
        id="price"
        type="number"
        :value="form.price"
        @input="$emit('update:price', Number(($event.target as HTMLInputElement).value))"
        :disabled="disabled"
      />
      <span v-if="errors.price" class="error">{{ errors.price }}</span>
    </div>

    <div class="form-actions">
      <button type="submit" :disabled="!canSubmit || disabled">
        {{ submitting ? '保存中...' : '保存' }}
      </button>
      <button type="button" @click="$emit('cancel')" :disabled="disabled">
        キャンセル
      </button>
    </div>
  </form>
</template>

<script setup lang="ts">
interface Props {
  form: {
    name: string
    price: number
  }
  errors: {
    name?: string
    price?: string
  }
  canSubmit: boolean
  submitting: boolean
  disabled?: boolean
}

withDefaults(defineProps<Props>(), {
  disabled: false
})

defineEmits<{
  'update:name': [value: string]
  'update:price': [value: number]
  submit: []
  cancel: []
}>()
</script>
```

### Widget での接続

```vue
<template>
  <ItemFormSection
    :form="form"
    :errors="errors"
    :can-submit="ui.canSubmit"
    :submitting="ui.submitting"
    @update:name="(v) => actions.updateField('name', v)"
    @update:price="(v) => actions.updateField('price', v)"
    @submit="handleSubmit"
    @cancel="handleCancel"
  />
</template>

<script setup lang="ts">
import { useRouter } from 'vue-router'
import { useItemForm } from './useItemForm'
import ItemFormSection from './sections/ItemFormSection.vue'

const router = useRouter()
const { form, errors, ui, actions } = useItemForm()

const handleSubmit = async () => {
  const result = await actions.submit()
  if (result.success) {
    router.push('/items')
  }
}

const handleCancel = () => {
  router.push('/items')
}
</script>
```

---

## 4. 共通 UI コンポーネントのパターン

### Button

```vue
<!-- components/Button/Button.vue -->
<template>
  <button
    :class="[
      'btn',
      `btn--${variant}`,
      `btn--${size}`,
      { 'btn--loading': loading }
    ]"
    :type="type"
    :disabled="disabled || loading"
    @click="$emit('click')"
  >
    <span v-if="loading" class="btn__spinner" />
    <slot />
  </button>
</template>

<script setup lang="ts">
interface Props {
  variant?: 'primary' | 'secondary' | 'danger'
  size?: 'sm' | 'md' | 'lg'
  type?: 'button' | 'submit' | 'reset'
  disabled?: boolean
  loading?: boolean
}

withDefaults(defineProps<Props>(), {
  variant: 'primary',
  size: 'md',
  type: 'button',
  disabled: false,
  loading: false
})

defineEmits<{
  click: []
}>()
</script>

<style scoped>
.btn {
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.btn--primary {
  background: #007bff;
  color: white;
}

.btn--secondary {
  background: #6c757d;
  color: white;
}

.btn--danger {
  background: #dc3545;
  color: white;
}

.btn--sm { padding: 4px 8px; font-size: 12px; }
.btn--md { padding: 8px 16px; font-size: 14px; }
.btn--lg { padding: 12px 24px; font-size: 16px; }

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn--loading {
  position: relative;
}
</style>
```

### TextField

```vue
<!-- components/TextField/TextField.vue -->
<template>
  <div :class="['text-field', { 'text-field--error': error }]">
    <label v-if="label" :for="id" class="text-field__label">
      {{ label }}
      <span v-if="required" class="text-field__required">*</span>
    </label>
    
    <input
      :id="id"
      :type="type"
      :value="modelValue"
      :placeholder="placeholder"
      :disabled="disabled"
      :readonly="readonly"
      class="text-field__input"
      @input="$emit('update:modelValue', ($event.target as HTMLInputElement).value)"
      @blur="$emit('blur')"
    />
    
    <span v-if="error" class="text-field__error">{{ error }}</span>
    <span v-else-if="hint" class="text-field__hint">{{ hint }}</span>
  </div>
</template>

<script setup lang="ts">
interface Props {
  modelValue: string
  label?: string
  placeholder?: string
  type?: 'text' | 'email' | 'password' | 'tel'
  error?: string
  hint?: string
  disabled?: boolean
  readonly?: boolean
  required?: boolean
  id?: string
}

withDefaults(defineProps<Props>(), {
  type: 'text',
  disabled: false,
  readonly: false,
  required: false,
  id: () => `field-${Math.random().toString(36).slice(2)}`
})

defineEmits<{
  'update:modelValue': [value: string]
  blur: []
}>()
</script>
```

---

## 5. 非同期処理のパターン

### ローディング・エラーの表示

```vue
<template>
  <!-- ローディング中 -->
  <div v-if="ui.loading" class="loading-container">
    <LoadingSpinner />
    <p>データを読み込んでいます...</p>
  </div>
  
  <!-- エラー -->
  <div v-else-if="ui.hasError" class="error-container">
    <ErrorIcon />
    <p>{{ errors.message }}</p>
    <Button @click="actions.retry">再試行</Button>
  </div>
  
  <!-- データなし -->
  <div v-else-if="ui.isEmpty" class="empty-container">
    <EmptyIcon />
    <p>データがありません</p>
  </div>
  
  <!-- 正常表示 -->
  <div v-else>
    <!-- コンテンツ -->
  </div>
</template>
```

### 楽観的更新（Optimistic Update）

```typescript
const actions = {
  async toggleFavorite(id: string) {
    // 1. 即座に UI を更新（楽観的更新）
    const item = items.value.find(i => i.id === id)
    if (!item) return
    
    const previousValue = item.isFavorite
    item.isFavorite = !item.isFavorite

    // 2. API 呼び出し
    try {
      await updateFavorite(id, item.isFavorite)
    } catch (e) {
      // 3. 失敗したら元に戻す
      item.isFavorite = previousValue
      error.value = '更新に失敗しました'
    }
  }
}
```

---

## 6. ルーター連携のパターン

### ルートパラメータの取得

```typescript
// pages/items/useItemDetail.ts
import { ref, computed, watch } from 'vue'
import { useRoute } from 'vue-router'
import { fetchItem } from '@/services/itemsService'

export const useItemDetail = () => {
  const route = useRoute()
  const item = ref<Item | null>(null)
  const loading = ref(false)
  const error = ref<string | null>(null)

  // ルートパラメータを監視
  const itemId = computed(() => route.params.id as string)

  const load = async () => {
    if (!itemId.value) return
    
    loading.value = true
    error.value = null
    
    try {
      item.value = await fetchItem(itemId.value)
    } catch (e) {
      error.value = '商品が見つかりません'
    } finally {
      loading.value = false
    }
  }

  // ID が変わったら再取得
  watch(itemId, load, { immediate: true })

  return {
    view: computed(() => ({ item: item.value })),
    ui: computed(() => ({ loading: loading.value, hasError: !!error.value })),
    errors: computed(() => ({ message: error.value }))
  }
}
```

### 画面遷移

```typescript
import { useRouter } from 'vue-router'

const router = useRouter()

// プログラマティック遷移
router.push('/items')
router.push({ name: 'ItemDetail', params: { id: '123' } })
router.replace('/login')
router.back()
```

---

## 7. Store（Pinia）との連携パターン

### Store の定義

```typescript
// stores/authStore.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { login, logout, getCurrentUser } from '@/services/authService'

export const useAuthStore = defineStore('auth', () => {
  const user = ref<User | null>(null)
  const token = ref<string | null>(localStorage.getItem('token'))

  const isAuthenticated = computed(() => !!token.value)
  const userName = computed(() => user.value?.name ?? '')

  const actions = {
    async login(email: string, password: string) {
      const result = await login(email, password)
      token.value = result.token
      user.value = result.user
      localStorage.setItem('token', result.token)
    },

    async logout() {
      await logout()
      token.value = null
      user.value = null
      localStorage.removeItem('token')
    },

    async fetchCurrentUser() {
      if (!token.value) return
      user.value = await getCurrentUser()
    }
  }

  return { user, isAuthenticated, userName, ...actions }
})
```

### model から Store を使う

```typescript
// pages/dashboard/useDashboard.ts
import { useAuthStore } from '@/stores/authStore'

export const useDashboard = () => {
  const authStore = useAuthStore()

  const view = computed(() => ({
    userName: authStore.userName,
    // ...
  }))

  const actions = {
    async logout() {
      await authStore.logout()
      router.push('/login')
    }
  }

  return { view, actions }
}
```

---

## まとめ：実装チェックリスト

新しいコンポーネントを作る前に確認：

- [ ] Page は Widget を配置するだけになっているか
- [ ] Widget は model から状態を取得しているか
- [ ] Section は props と emit だけで完結しているか
- [ ] API 呼び出しは services に分離しているか
- [ ] バリデーションは domain に分離しているか
- [ ] エラー・ローディング状態を考慮しているか

---

## 次のステップ

実装パターンを理解したら、[05_Storybook入門](./05_Storybook入門.md) でコンポーネントの確認方法を学びましょう。
