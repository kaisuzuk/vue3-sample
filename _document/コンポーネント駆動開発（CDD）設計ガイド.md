# コンポーネント駆動開発（CDD）設計ガイド

（Vueマイグレーション・チーム共通理解用）

---

## この資料の目的

この資料は、Vueマイグレーションにおいて採用する「コンポーネント駆動開発（CDD）」の考え方を、チーム全体で共通理解として持つためのものです。
目的は次の4点です。

1. コンポーネント設計で迷うポイントを減らす
2. データの流れを誰でも追えるようにする
3. 「どこに何を書くべきか」を明確にする
4. 人による実装ブレを防ぐ

---

## コンポーネント駆動開発（CDD）とは何か

CDDとは、画面を起点に開発するのではなく、「コンポーネント」を最小の開発単位として考える開発思想です。従来の画面駆動開発では、

* まず画面を作る
* 大きくなったら後から部品に切り出す

という流れになりがちでした。CDDでは逆に、

* 状態を持ったコンポーネントを先に作る
* それらを組み合わせた結果が画面になる

という考え方を取ります。画面は「完成形」であり、開発の主役はあくまでコンポーネントです。

---

## CDDの基本原則

### 原則1：コンポーネントは「状態・表示・振る舞い」を持つ

コンポーネントは単なるHTMLの断片ではありません。

* どんな状態が存在するのか
* その状態でどう表示されるのか
* ユーザー操作でどう振る舞うのか

を、コンポーネント単体で説明できる必要があります。例としては以下のような状態があります。

* 通常状態
* 入力途中
* バリデーションエラー
* 送信中
* 送信失敗

これらを「画面に組み込まないと確認できない」状態にしないことが重要です。

---

### 原則2：画面は「組み合わせ結果」でしかない

画面はロジックを持つ場所ではありません。

* 画面固有のif文
* 画面内に直接書かれたビジネスロジック
* 画面から直接APIを呼ぶ処理

こうしたものは作らないようにします。

画面は「どのコンポーネントを、どの順番で並べるか」を決めるだけの存在です。

---

### 原則3：データの流れは一本道にする

データの流れが複雑になる最大の原因は「状態があちこちに散らばること」です。CDDでは次を徹底します。

* 状態を持つ場所は1箇所
* データは props で下に流す
* 変更は emit で上に戻す

このルールを守るだけで、コンポーネントが増えてもデータの流れは追いやすくなります。

---

## 採用する「わかりやすい構成（最小構成）」

今回のVueマイグレーションでは、自由度の高い構成よりも「迷わない構成」を優先します。採用する構成は以下の考え方です。

* pages：画面の入口
* widgets：画面の骨組み
* sections：意味のある入力・表示の塊
* features/model：状態とビジネスロジック
* entities：ドメインとしての正しさ
* shared/ui：共通UI部品

---

## pages の役割

pages はルーティングの入口です。pages がやってよいことは次のような内容です。

* ルーティングに対応するコンポーネントを置く
* 画面遷移を制御する
* 必要であれば権限チェックを行う

一方で、次のことは禁止します。

* フォームの状態管理
* 入力ロジック
* API呼び出し

pages は「画面の外側」だけを担当します。

---

## widgets の役割

widgets は1画面を構成するための「見た目の親」です。widgets の役割は以下です。

* sections を並べる
* 状態を子コンポーネントに props で配る
* 子からのイベントを受けて actions を呼ぶ

widgets 自身は「状態の真実」を持ちません。状態は必ず model（features）に委ねます。

---

## sections の役割

sections は画面を意味のある塊に分けた中粒度のコンポーネントです。例としては、

* 基本情報セクション
* 作業量入力セクション
* 写真入力セクション
* メモ入力セクション

などが該当します。sections の責務は非常にシンプルです。

* 値を props で受け取る
* ユーザー操作を emit で返す

sections では以下を行ってはいけません。

* API呼び出し
* 状態の真実を持つこと
* ビジネスロジックの実装

カルーセルの現在位置など、純粋にUI上の都合で必要な状態のみ持つことは許容します。

---

## features/model の役割（最重要）

features/model は、この構成の「心臓部」です。ここに以下のものをすべて集約します。

* 入力値（form）
* UI状態（送信中、touched、dirty など）
* バリデーション結果（errors）
* 操作（actions）
* API呼び出し

model が公開する形は原則として固定します。

* form：入力値の唯一の真実
* ui：表示制御用の状態
* errors：バリデーション結果
* actions：状態更新・送信などの操作

コンポーネント側が form を直接書き換えることは禁止し、必ず actions 経由で更新します。

---

## entities の役割

entities は「ドメインとして正しいか」を判断する場所です。ここでは以下を守ります。

* UIに依存しない
* APIに依存しない
* 副作用を持たない純関数

例としては、

* 作業記録として成立するか
* 数値範囲が正しいか
* 日付の整合が取れているか

といったチェックを行います。

---

## shared/ui の役割

shared/ui はアプリ全体で使い回すUI部品です。

* テキスト入力
* 数値入力
* カルーセル
* ボタン

などが該当します。ここでは、

* 見た目
* 入力体験
* アクセシビリティ

に集中し、業務ロジックやAPI処理は一切持ちません。

---

## データの流れ（最重要）

この構成では、データの流れは常に次の一本道になります。

1. model が状態を持つ
2. widget が状態を受け取り sections に配る
3. sections が emit で変更を通知する
4. widget が actions を呼ぶ
5. model の状態が更新される

この流れが崩れたら設計ミスのサインです。

---

## バリデーションの分担

* ドメインとしての正しさ：entities
* UIで使う形への整形：features/model
* 表示：sections

バリデーションロジックを UI に書かないことが重要です。

---

## Storybook / MSW との関係

CDDでは Storybook を使って、sections や shared/ui を単体で開発・確認します。APIが必要な部分は MSW を使ってモックします。
これにより、

* UI
* ビジネスロジック
* API

を分離したまま開発が可能になります。

---

## よくあるアンチパターン

* 子コンポーネントが状態の真実を持つ
* UIから直接APIを呼ぶ
* form を直接書き換える
* バリデーションが散らばる
* v-model の多段バケツリレー

---

## 判断に迷ったら

以下を自問してください。

* この状態の真実はどこか？
* これはUIの都合か、ビジネスルールか？
* props と emit だけで説明できるか？

答えが曖昧なら、設計を見直すタイミングです。

---

## まとめ

* CDDは「作り方の思想」
* 構成は「迷わないための制約」
* 状態は1箇所に集める
* データフローは一本道
* 小さく作り、組み合わせる
